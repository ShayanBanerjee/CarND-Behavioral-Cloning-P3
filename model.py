# -*- coding: utf-8 -*-
"""model.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Q1s_PrfE8M0zS7o_9Exk8z1K1fu7GdmK
"""

# Commented out IPython magic to ensure Python compatibility.
import os
import csv
import numpy as np
import pandas as pd
from skimage import io
import matplotlib.pyplot as plt
# %matplotlib inline

from google.colab import files
uploaded = files.upload()

lines = []

with open('driving_log.csv') as csvfile:
    reader = csv.reader(csvfile)
    next(reader, None)
    for line in reader:
        lines.append(line)

data = pd.read_csv('driving_log.csv')
data.head()

data.shape

lines[0]

from google.colab import drive
drive.mount('/content/drive')

import os
os.chdir("/content/drive/My Drive/car_drive_data")
!ls

import zipfile
zip_ref = zipfile.ZipFile("/content/drive/My Drive/car_drive_data/IMG.zip", 'r') 
zip_ref.extractall("IMG") 
zip_ref.close()

os.getcwd()

images = []
measurements = []
for line in lines:
    centre_path = "/content/drive/My Drive/car_drive_data/IMG/IMG/" + line[0].split('\\')[-1]
    left_path = "/content/drive/My Drive/car_drive_data/IMG/IMG/" + line[1].split('\\')[-1]
    right_path = "/content/drive/My Drive/car_drive_data/IMG/IMG/" + line[2].split('\\')[-1]
    
    image_centre =  io.imread(centre_path)

    image_left =  io.imread(left_path)
    #image_left = cv2.cvtColor(image_left, cv2.COLOR_BGR2RGB)

    image_right = io.imread(right_path)
    #image_right = cv2.cvtColor(image_right, cv2.COLOR_BGR2RGB)

    correction = 0.2

    images.append(image_left)
    measurements.append(float(line[3]) + correction)

    images.append(image_right)
    measurements.append(float(line[3]) - correction)
    
    images.append(image_centre)
    
    measurement = float(line[3])
    measurements.append(measurement)

# data augmentation
aug_images, aug_measurements = [], []
for image, measurement in zip(images, measurements):
    aug_images.append(image)
    aug_measurements.append(measurement)
    aug_images.append(np.fliplr(image)) # this rotates the image
    aug_measurements.append(measurement*-1.0) # gives the measurement a opposite value now

X_train = np.array(aug_images)
y_train = np.array(aug_measurements)

X_train.shape

plt.imshow(X_train[0])
plt.show()

from keras.models import Sequential
from keras.layers.core import Dense, Flatten, Activation, Dropout
from keras.layers.convolutional import Convolution2D, Conv2D
from keras.layers import Lambda, Cropping2D

model = Sequential()

# Preprocess incoming data, centered around zero with small standard deviation 
model.add(Lambda(lambda x: (x / 255.0) - 0.5, input_shape=(160,320,3)))

# trim image to only see section with road
model.add(Cropping2D(cropping=((70,25),(0,0))))           

#layer 1- Convolution, no of filters- 24, filter size= 5x5, stride= 2x2
model.add(Conv2D(24, (5, 5), strides = (2,2), activation = "relu"))

#layer 2- Convolution, no of filters- 36, filter size= 5x5, stride= 2x2
model.add(Conv2D(36, ( 5,5), strides=(2,2), activation= "relu"))

#layer 3- Convolution, no of filters- 48, filter size= 5x5, stride= 2x2
model.add(Conv2D(48, (5, 5), strides=(2,2), activation= "relu"))

#layer 4- Convolution, no of filters- 64, filter size= 3x3, stride= 1x1
model.add(Conv2D(64, (3, 3) , activation= "relu"))

#layer 5- Convolution, no of filters- 64, filter size= 3x3, stride= 1x1
model.add(Conv2D(64, (3, 3), activation= "relu"))

#flatten image from 2D to side by side
model.add(Flatten())

#layer 6- fully connected layer 1
model.add(Dense(100, activation= "relu"))

#Adding a dropout layer to avoid overfitting. Here we are have given the dropout rate as 25% after first fully connected layer
model.add(Dropout(rate=0.25))

#layer 7- fully connected layer 1
model.add(Dense(50, activation= "relu"))


#layer 8- fully connected layer 1
model.add(Dense(10, activation= "relu"))

#layer 9- fully connected layer 1
model.add(Dense(1)) #here the final layer will contain one value as this is a regression problem and not classification


# the output is the steering angle , i.e regression, now using adam optimizer and  using mean squared error loss function
model.compile(loss='mse',optimizer='adam')

# training the model
# epoch = 10 , batch_size = 32
history = model.fit(X_train, y_train, batch_size = 32, epochs = 10, validation_split=0.2, verbose= 1, shuffle= True)

plt.plot(history.history['val_loss'], 'r')

#saving model
model.save('model.h5')

print('Model Saved')

# keras method to print the model summary
model.summary()

from google.colab import files
files.download("/content/drive/My Drive/car_drive_data/IMG/IMG/model.h5")

